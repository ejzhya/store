class 6:inline、const、static、全局变量
inline 内联：这个函数是内联的
inline int plusOne(int x);//无意义，inline 定义即声明
函数声明 编译器用小本本把函数声明记下,声明不会在.o文件留下东西
ls *.o
ls -l *.o
inline 是声明其函数体body也是声明 类的inline函数body都要放在.h头文件
const declare a variable to have a const value常变量
int a=6;//literal   以前constant instant立即数
1.char* const q="abc";//q is const 指针指向的对象不能变，地址不变
2.const char*p="abc";//指针指向的对象是char型且值不能变
const 在*前是一类2，在后是1类
overload 函数名称相同 参数表不同
静态本地变量static 
静态全局变量static 访问受限 static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
class 7:namespace、inheritance
namespace, avoiding name clashed
class 大括号后面后有分号； 是因为可以在定义的时候直接定义一个新对象，namespace不需要
using MyLib::foo;//用具体的一个东西，mylib中的foo
::归属于
函数重载 f(int) f(double)会根据输进去的参数选择其中一个函数
__A_f_int
用老c extern "C"
继承inheritance The ability to define the behavior or implementation of one class as a superset of another class.
终端编译g++ -c employee.cpp
g++ -c employee.cpp main.cpp
//引用代替指针
int foo(const string &myname) {
  cout << "called foo for: " << myname << endl;
  return 0;
}
it can never be NULL
it must always be initialised
it cannot be changed to refer to a different variable once set
it can be used in exactly the same way as the variable to which it refers (which means you do not need to deference it like a pointer)

./a.out

名词隐藏，父类的函数在子类重新写了以后父类的函数就不会执行了